package ch.uzh.seal.detectors.gitlabyaml.detectors;

import ch.uzh.seal.antipattern.entities.CIAntiPattern;
import ch.uzh.seal.project.entities.LintProject;
import ch.uzh.seal.detectors.gitlabyaml.entities.GitLabYAML;
import ch.uzh.seal.detectors.gitlabyaml.entities.Job;
import ch.uzh.seal.utils.LineNumberExtractor;
import ch.uzh.seal.utils.LineNumberPathConstructor;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GitLabYAMLVulnerabilityDetector extends GitLabYAMLDetector {

    private String category = "Vulnerability";

    private List<Pattern> keywords = getKeywords();

    public GitLabYAMLVulnerabilityDetector(LintProject project) {
        super(project);
    }

    public List<CIAntiPattern> lint() {
        List<CIAntiPattern> antiPatterns = new ArrayList<>();

        GitLabYAML gitLabYAML = getGitLabYAML(project);

        LineNumberExtractor lineNumberExtractor = new LineNumberExtractor(gitLabYAML.getRaw());

        Map<String, String> variables = gitLabYAML.getVariables();

        Map<String, Job> jobs = gitLabYAML.getJobs();

        String cfgFileName = ".gitlab-ci.yml";
        String projectName = project.getName();
        String remoteRepoPath = project.getRemotePath();
        String remoteCfgLink = project.getFullRemotePath(cfgFileName, true);
        String localCfgLink = project.getFullLocalPath(cfgFileName);

        for (String jobName : jobs.keySet()) {
        	
        	if(jobName.startsWith("."))
        		continue;
        	
        	
            Job job = jobs.get(jobName);
            String stage = job.getStage();
            List<String> script = job.getScript();

            for (String statement : script) {

                for (String keyword : getSecurityKeywords(statement, variables)) {
                    CIAntiPattern antiPattern = new CIAntiPattern();

                    String lineNumber = lineNumberExtractor.getLineNumber(keyword);
                    //String lineNumberPath = LineNumberPathConstructor.getPath(remoteCfgLink, lineNumber);

                    antiPattern.setId(generateID(projectName, keyword));
                    antiPattern.setProject(projectName);
                    antiPattern.setRemoteRepoLink(remoteRepoPath);
                    antiPattern.setRemoteCfgLink(remoteCfgLink);
                    antiPattern.setLocalCfgLink(localCfgLink);
                    antiPattern.setStage(stage);
                    antiPattern.setCategory(category);
                    antiPattern.setEntity(jobName);
                    antiPattern.setMessage(keyword);
                    antiPattern.setContext(gitLabYAML.getRaw());
                    antiPattern.setLineNumber(lineNumber);
                    antiPattern.setCfgFileName(cfgFileName);
                    antiPatterns.add(antiPattern);
                }
            }
        }

        return antiPatterns;
    }

    /**
     * This method reads the special keywords that need to be included in the matched regexs
     * @return
     */
    private List<Pattern> getKeywords() {
        List<Pattern> keywords = new ArrayList<>();

        String path = "src/main/resources/security-keywords.txt";
        File file = new File(path);

        Scanner scanner;

        try {
            scanner = new Scanner(file);
        }
        catch (FileNotFoundException e) {
            System.out.println(path+" not found");
            return null;
        }

        while (scanner.hasNextLine()){
            String keyword = scanner.nextLine().strip();
            if (!keyword.equals("")) {
                String regex = "(?i:( |\\S+[-_])"+keyword+"([-_]\\w+)?=(\\S+))";
                Pattern pattern = Pattern.compile(regex);
                keywords.add(pattern);
            }
        }

        return keywords;
    }

    /**
     * This method has the goal of capturing vulnerabilities in the config file (those are displayed in the generated issues)
     * @param statement
     * @param variables
     * @return
     */
    private Set<String> getSecurityKeywords(String statement, Map<String, String> variables) {
        Set<String> securityKeywords = new HashSet<>();

        for (Pattern rgx : keywords) {

            Matcher matcher = rgx.matcher(statement);

            if (matcher.find()) {

                String expression = matcher.group();
                


                if (inBlackList(expression)) {
                    continue;
                }

                if (isFileOption(expression)) {
                    continue;
                }

                String keyword = getKeyWord(matcher);
                

                if (hasFileExtension(keyword)) {
                    continue;
                }
                
                // check for the definition of the keyword in the variables' section of the file
                if(keyword.startsWith("$")) { // strip $
                	String variable = keyword.substring(1);
                
                if (variables.containsKey(variable)) {
                    securityKeywords.add(keyword);
                }}
                else {
                	securityKeywords.add(expression);
                }
            }
        }

        return securityKeywords;
    }

    private String getKeyWord(Matcher matcher) {
        String keyword;

        if (matcher.groupCount() == 2) {
            keyword = matcher.group(2);
        }
        else {
            keyword = matcher.group(3);
        }

        // strip whitespaces
        keyword = keyword.strip();

        // strip quotes
        if (keyword.startsWith("\"")) {
            keyword = keyword.substring(1, keyword.length()-1);
        }
        return keyword;
    }


    private Boolean inBlackList(String expression) {
        expression = expression.toLowerCase();

        if (expression.contains("stricthostkeychecking") || expression.contains("gitlab-ci-token")) {
            return true;
        }

        return false;
    }

    private Boolean isFileOption(String expression) {
        expression = expression.toLowerCase();

        return expression.contains("file");
    }

    private Boolean hasFileExtension(String keyword) {
        return keyword.matches(".*\\.\\w{1,4}");
    }

    public String generateID(String projectName, String keyword) {
        return removeIllegalCharsInID(projectName + "__" + category + "__" + keyword);
    }
}
